package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.74

import (
	"context"
	"fmt"
	"math/rand"
	"products-service/graph/model"
)

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input model.CreateProductInput) (*model.Product, error) {
	// Generate new ID
	newID := fmt.Sprintf("%d", rand.Intn(10000))

	// Create new product
	stock := int32(input.Stock)
	newProduct := &model.Product{
		ID:          newID,
		Name:        input.Name,
		Description: input.Description,
		Price:       input.Price,
		Stock:       &stock,
		Category:    input.Category,
	}

	// Add to product slice
	products = append(products, newProduct)

	// Return new product
	return newProduct, nil
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, input model.UpdateProductInput) (*model.Product, error) {
	fmt.Printf("UpdateProduct called with IDL %v\n", input.ID)
	// Find the product to update
	for i, product := range products {
		// Only update fields that are not nil
		if product.ID == input.ID {
			if input.Name != nil{
				product.Name =*input.Name
			}
			if input.Description != nil{
				product.Description = *input.Description
			}
			if input.Price != nil{
				product.Price = *input.Price
			}
			if input.Stock != nil{
				product.Stock = input.Stock
			}
			if input.Category != nil{
				product.Category = *input.Category
			}
			// Replace in slice
			products[i] = product
			return product, nil
		}
	}
	return nil, fmt.Errorf("product not found")
}

// DeleteProduct is the resolver for the deleteProduct field.
func (r *mutationResolver) DeleteProduct(ctx context.Context, id string) (bool, error) {
	// fid the product index
	for i, product := range products {
		if product.ID == id {
			// remove it from the slice
			products = append(products[:i], products[i+1:]...)
			// return sucess
			return true, nil
		}
	}
	// Product not found
	return false, fmt.Errorf("product with id %s not found", id)
}

// GetProduct is the resolver for the getProduct field.
func (r *queryResolver) GetProduct(ctx context.Context, id *string) (*model.Product, error) {
	if id == nil {
		return nil, fmt.Errorf("id cannot be nil")
	}
	fmt.Printf("Looking for product with ID: '%s'\n", *id)

	for _, product := range products {
		if product.ID == *id {
			return product, nil
		}
	}
	return nil, fmt.Errorf("product not found")
}

// GetAllProducts is the resolver for the getAllProducts field.
func (r *queryResolver) GetAllProducts(ctx context.Context) ([]*model.Product, error) {
	fmt.Printf("Returning %d products\n", len(products))
	return products, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
