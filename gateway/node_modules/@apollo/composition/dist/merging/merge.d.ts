import { DirectiveDefinition, Schema, Subgraphs, JoinSpecDefinition, JoinFieldDirectiveArguments } from "@apollo/federation-internals";
import { GraphQLError } from "graphql";
import { CompositionHint } from "../hints";
import { CompositionOptions } from "../compose";
export type Sources<T> = Map<number, T | undefined>;
export declare function sourcesFromArray<T>(array: (T | undefined)[]): Sources<T>;
export type MergeResult = MergeSuccess | MergeFailure;
export interface MergeSuccess {
    supergraph: Schema;
    hints: CompositionHint[];
    errors?: undefined;
}
export interface MergeFailure {
    errors: GraphQLError[];
    supergraph?: undefined;
    hints?: undefined;
}
export declare function isMergeSuccessful(mergeResult: MergeResult): mergeResult is MergeSuccess;
export declare function isMergeFailure(mergeResult: MergeResult): mergeResult is MergeFailure;
export declare function mergeSubgraphs(subgraphs: Subgraphs, options?: CompositionOptions): MergeResult;
export declare class AuthValidator {
    schema: Schema;
    joinSpecNamesToSubgraphNames: Map<string, string>;
    joinFieldDirective: DirectiveDefinition<JoinFieldDirectiveArguments>;
    authenticatedDirective?: DirectiveDefinition;
    requiresScopesDirective?: DirectiveDefinition<{
        scopes: string[][];
    }>;
    policyDirective?: DirectiveDefinition<{
        policies: string[][];
    }>;
    contexts: Map<string, string[]>;
    constructor(schema: Schema, joinSpec: JoinSpecDefinition, subgraphNamesToJoinSpecName: Map<string, string>);
    validateRequiresFieldSet(coordinate: string): GraphQLError[];
    validateFromContext(coordinate: string): GraphQLError[];
    private authRequirementsOnElement;
    private verifyAuthRequirementsOnSelectionSet;
    private verifyAuthOnFieldSelection;
}
//# sourceMappingURL=merge.d.ts.map