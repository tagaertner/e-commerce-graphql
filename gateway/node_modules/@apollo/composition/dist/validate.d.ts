import { CompositeType, FieldDefinition, Operation, Schema, SchemaRootKind, NamedType } from "@apollo/federation-internals";
import { Edge, QueryGraph, RootPath, Transition, QueryGraphState, TransitionPathWithLazyIndirectPaths, RootVertex, ConditionResolver, Vertex } from "@apollo/query-graphs";
import { CompositionHint } from "./hints";
import { GraphQLError } from "graphql";
import { CompositionOptions } from './compose';
export declare class ValidationError extends Error {
    readonly supergraphUnsatisfiablePath: RootPath<Transition>;
    readonly subgraphsPaths: RootPath<Transition>[];
    readonly witness: Operation;
    constructor(message: string, supergraphUnsatisfiablePath: RootPath<Transition>, subgraphsPaths: RootPath<Transition>[], witness: Operation);
}
export declare function validateGraphComposition(supergraphSchema: Schema, subgraphNameToGraphEnumValue: Map<string, string>, supergraphAPI: QueryGraph, federatedQueryGraph: QueryGraph, compositionOptions?: CompositionOptions): {
    errors?: GraphQLError[];
    hints?: CompositionHint[];
};
export declare function extractValidationError(error: any): ValidationError | undefined;
export declare class ValidationContext {
    readonly supergraphSchema: Schema;
    readonly subgraphNameToGraphEnumValue: Map<string, string>;
    private readonly joinTypeDirective;
    private readonly joinFieldDirective;
    private readonly typesToContexts;
    constructor(supergraphSchema: Schema, subgraphNameToGraphEnumValue: Map<string, string>);
    isShareable(field: FieldDefinition<CompositeType>): boolean;
    matchingContexts(typeName: string): string[];
}
type SubgraphPathInfo = {
    path: TransitionPathWithLazyIndirectPaths<RootVertex>;
    contexts: Map<string, {
        subgraphName: string;
        typeName: string;
    }>;
};
declare class SubgraphPathInfos {
    readonly paths: SubgraphPathInfo[];
    constructor(paths: SubgraphPathInfo[]);
}
declare class TopLevelMutationFieldSubgraphPathInfos {
    readonly mutationField: FieldDefinition<CompositeType>;
    readonly paths: Map<string, SubgraphPathInfo[]>;
    constructor(mutationField: FieldDefinition<CompositeType>, paths: Map<string, SubgraphPathInfo[]>);
}
export declare class ValidationState {
    readonly supergraphPath: RootPath<Transition>;
    readonly subgraphPathInfos: SubgraphPathInfos | TopLevelMutationFieldSubgraphPathInfos;
    selectedOverrideConditions: Map<string, boolean>;
    constructor(supergraphPath: RootPath<Transition>, subgraphPathInfos: SubgraphPathInfos | TopLevelMutationFieldSubgraphPathInfos, selectedOverrideConditions?: Map<string, boolean>);
    static initial({ supergraphAPI, kind, federatedQueryGraph, conditionResolver, overrideConditions, }: {
        supergraphAPI: QueryGraph;
        kind: SchemaRootKind;
        federatedQueryGraph: QueryGraph;
        conditionResolver: ConditionResolver;
        overrideConditions: Map<string, boolean>;
    }): ValidationState;
    canSkipVisit(subgraphNameToGraphEnumValue: Map<string, string>, previousVisits: QueryGraphState<VertexVisit[]>): boolean;
    canSkipVisitForSubgraphPaths(supergraphPathTail: Vertex, subgraphPathInfos: SubgraphPathInfo[], subgraphNameToGraphEnumValue: Map<string, string>, previousVisits: QueryGraphState<VertexVisit[]>): boolean;
    validateTransition(context: ValidationContext, supergraphEdge: Edge, matchingContexts: string[], validationErrors: GraphQLError[], satisfiabilityErrorsByMutationFieldAndSubgraph: Map<string, Map<string, GraphQLError[]>>): {
        state?: ValidationState;
        hint?: CompositionHint;
    };
    validateTransitionForSubgraphPaths(subgraphPathInfos: SubgraphPathInfo[], newOverrideConditions: Map<string, boolean>, transition: Transition, targetType: NamedType, matchingContexts: string[], newPath: RootPath<Transition>): {
        newSubgraphPathInfos: SubgraphPathInfo[];
        error?: never;
    } | {
        newSubgraphPathInfos?: never;
        error: GraphQLError;
    };
    private static fieldIfTopLevelMutation;
    private static subgraphOfTopLevelMutation;
    allSubgraphPathInfos(): SubgraphPathInfo[];
    allSubgraphPathsCount(): number;
    currentSubgraphNames(): string[];
    currentSubgraphContextKeys(subgraphNameToGraphEnumValue: Map<string, string>, subgraphPathInfos: SubgraphPathInfo[]): Set<string>;
    currentSubgraphs(): {
        name: string;
        schema: Schema;
    }[];
    toString(): string;
}
interface VertexVisit {
    subgraphContextKeys: Set<string>;
    overrideConditions: Map<string, boolean>;
}
export {};
//# sourceMappingURL=validate.d.ts.map